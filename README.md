# 🏗 Scaffold-ETH - ZK Voting Example!

> everything you need to build on Ethereum! 🚀

A simple zk voting example.

Please go through the [zk-prove-membership](https://github.com/scaffold-eth/scaffold-eth-examples/tree/zk-prove-membership) branch before getting too deep into this one!

# Circuits

```
packages
├── hardhat
│   ├── circuits
|   │   ├── add2Tree
|   |   |   ├── add2Tree.circom
|   |   |   └── input.json
|   │   └── proveInTree
|   |       ├── proveInTree.circom
|   |       └── input.json
|   └── powersOfTau28_hez_final_15.ptau
├── react-app
├── services
└── subgraph
```

### `proveInTree.circom` Modifications

We have made a couple modifications to the `proveInTree` circuit from the [zk-prove-membership](https://github.com/scaffold-eth/scaffold-eth-examples/tree/zk-prove-membership) branch. First of all, we have added two new signals, one public input signal and one output signal.

`voteId`: the ID for the proposal you would like to vote on.

`voterHash`: a unique hash used to make sure no one votes more than once.

So how do we generate the `voterHash`? Like this!

```
  poseidon[1] = Poseidon(3);
  poseidon[1].inputs[0] <== voteId;
  poseidon[1].inputs[1] <== key;
  poseidon[1].inputs[2] <== nullifier;
  voterHash <== poseidon[1].out;
```

All we have to do is run the `voteId`, `key`, and `nullifier` signals through a poseidon hash circuit!

And that pretty much covers all of the modifications we made to the circuit.

# Smart Contract

We also have to make a few additions to the smart contract. First we added a bunch of new state variables.

```
    uint256 public voteNonce;

    mapping(uint256 => bool) public voteLogged;
    mapping(uint256 => int256) public voteResult;
    mapping(uint256 => uint256) public voteDeadline;
```

`voteNonce`: a counter used to assign unique `voteIds` to vote proposals.

`voteLogged`: used to log the unique hash generated by the circuit described above.

`voteResult`: tracks the number of positive and negative votes for a `voteId`.

`voteDeadline`: the timestamp at which voting for the specified `voteId` will be closed.

Then of course we have a function to create a new vote.

```
    function createVote(uint256 deadline) external {
        require(deadline > block.timestamp, "createVote: Invalid Deadline");

        uint256 voteId = voteNonce;
        voteNonce++;
        voteDeadline[voteId] = deadline;

        emit CreateVote(voteId, deadline);
    }
```

The function takes one argument `deadline`, which will be the time by which voting will be closed. Next, is the require statement that enforces `deadline` is larger than the current timestamp. (There is a potential exploit here, see if you can figure it out!)

Then we increase the `voteNonce`, set the deadline, and emit an event for the vote creation.

#### `proveMembership()` Modifications

Now we have a snazzed up version of the `proveMembership()` function from the [zk-prove-membership](https://github.com/scaffold-eth/scaffold-eth-examples/tree/zk-prove-membership) branch. It's nearly identical to the old function, except we have one more argument, and we do something a tad bit more interesting than just approving an address.

```
    function proveMembership(
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[3] memory input,
        bool slant
    ) external returns (bool r) {
        require(voteLogged[input[0]] != true, "proveMembership: Vote Logged");
        require(voteDeadline[input[2]] > block.timestamp, "proveMembership: Deadline Passed");
        require(input[1] == root, "proveMembership: Invalid Root");

        r = verifyProveInTreeProof(a, b, c, input);
        require(r == true, "proveMembership: Invalid Proof");

        voteLogged[input[0]] = true;
        if (slant == true) {
            voteResult[input[2]] += 1;
        } else {
            voteResult[input[2]] -= 1;
        }
    }
```

`slant`: a bool determining if we will vote positively or negatively towards the `voteId` provided by the proof.

We've added two new require statements to the top of the function. The first checks that this voter has not voted yet, if they have the transaction fails. The second ensures that we have not passed the `voteId`'s set deadline yet.

Next we log the unique hash generated by the proof and ensure that the voter will not be able to vote on this proposal again.

And finally we check if `slant` is `true` or `false`, if `true` we add one vote, if `false` we subtract a vote.

# Flaws

Most if not all of the flaws from the [zk-prove-membership](https://github.com/scaffold-eth/scaffold-eth-examples/tree/zk-prove-membership) branch will also apply to this.

And, in addition, there is a potential exploit that someone may call `createVote()` with a deadline one second above the current block timestamp, then in the same transaction vote for their own proposal, preventing anybody else from voting on their proposal. If additional functionality is added to this, this may become a serious exploit vector.

# Final Thoughts

All in all this is a pretty boring implementation of zk voting, all it does is track some numbers. I hope you feel challenged to build something a little more interesting on top of this. Maybe have a vote make external calls after a certain threshold? Be careful of unseen attack vectors! There are probably things I forgot to mention ;p

# 💌 P.S.

🌍 You need an RPC key for testnets and production deployments, create an [Alchemy](https://www.alchemy.com/) account and replace the value of `ALCHEMY_KEY = xxx` in `packages/react-app/src/constants.js` with your new key.

# 🏃💨 Speedrun Ethereum
Register as a builder [here](https://speedrunethereum.com) and start on some of the challenges and build a portfolio.


# 💬 Support Chat

Join the telegram [support chat 💬](https://t.me/joinchat/KByvmRe5wkR-8F_zz6AjpA) to ask questions and find others building with 🏗 scaffold-eth!

---

🙏 Please check out our [Gitcoin grant](https://gitcoin.co/grants/2851/scaffold-eth) too!
