# 🏗 Scaffold-ETH - Prove Membership with Circom and Zero Knowledge

> everything you need to build on Ethereum! 🚀

If you haven't taken a look at the [circom starter kit](https://github.com/scaffold-eth/scaffold-eth-examples/tree/circom-starter-kit) or the [circom contract tutorial](https://github.com/scaffold-eth/scaffold-eth-examples/tree/circom-contract-tutorial) it would be a good idea to check those out before getting to deep into this branch!

This repo aims to be a foundation to rapidly prototype any contract that needs addresses to anonymously prove that a secret they know is contained within a list. How are we going to do this? With merkle trees and zero knowledge of course!

There are two main things we will want this contract to do:
- Add secrets to the merkle tree
- Prove anonymously the knowledge of a secret in the merkle tree

We'll do this with two circuits.

# Circuits

Our two circuits will appropriately be called `add2Tree` and `proveInTree` and located in the project as seen below.

```
packages
├── hardhat
│   ├── circuits
|   │   ├── add2Tree
|   |   |   ├── add2Tree.circom
|   |   |   └── input.json
|   │   └── proveInTree
|   |       ├── proveInTree.circom
|   |       └── input.json
|   └── powersOfTau28_hez_final_15.ptau
├── react-app
├── services
└── subgraph
```

### `add2Tree.circom`

We will use this circuit to add a secret to our merkle tree. This circuit is basically a nice wrapper around the [`smtprocessor.circom`](https://github.com/iden3/circomlib/blob/master/circuits/smt/smtprocessor.circom) found in [circomlib](https://github.com/iden3/circomlib).

This circuit has 6 input signals and one output signal.

```
  signal input oldRoot; // should be defined in contract
  signal input newKey;  // should be defined in contract
  signal input newValue;
  signal input oldKey;
  signal input oldValue;
  signal private input siblings[nLevels];

  signal output outRoot;
```

#### Inputs

`oldRoot` is the previous root of the merkle tree we will be updating. The root of our tree will be recorded within our smart contract.

`newKey` is the index at which we will be adding a secret to the merkle tree. The next key will be enforced by our smart contract.

`newValue` is the value that will be recorded at the index defined above. It should be a hash of a secret and a nullifier. Our smart contract will record this value so others can reconstruct the merkle tree.

`oldKey` is the other index needed to reconstruct the merkle tree.

`oldValue` is the value that has been recorded at the index defined above.

`siblings` is an array of the intermediate hashes up to the root of the merkle tree. This input is private to save space, not out of necessity.

#### Output

`outRoot` is the new root of the merkle tree calculated using the new values.

We take all of these input signals and pass them to an `SMTProcessor` component.

```
  component rootIsZero = IsZero();
  rootIsZero.in <== oldRoot;

  component tree = SMTProcessor(nLevels);
  tree.oldRoot <== oldRoot;
  for (var i=0; i<nLevels; i++) tree.siblings[i] <== siblings[i];
  tree.oldKey <== oldKey;
  tree.oldValue <== oldValue;
  tree.isOld0 <== rootIsZero.out;
  tree.newKey <== newKey;
  tree.newValue <== newValue;
  tree.fnc[0] <== 1;
  tree.fnc[1] <== 0;

  outRoot <== tree.newRoot;
```

Then we assign the root generated by our `SMTProcessor` component to our output signal `outRoot`.

But wait! What are the two lines at the top of that code block?

We need to determine if the tree we're trying to add our secret to is empty or not. To do this we pass the `oldRoot` signal to an `isZero` circuit, and that circuit's output to the `SMTProcessor`.

This circuit takes a parameter called `nLevels`. Setting this param determines how many values our merkle tree may hold (`2^nLevels`). In this example `nLevels` is set to 3 Feel free to modify it in the circuit file, but be sure to also change `nLevels` in `proveInTree.circom`, just add one to your `nLevels` in that file.

### `proveInTree.circom`

Our second will allow us to prove that we know a secret that is contained within the merkle tree, without revealing which secret we know.

Again, this circuit is basically a nice wrapper for another circuit. In this case the [`smtverifier.circom`](https://github.com/iden3/circomlib/blob/master/circuits/smt/smtverifier.circom) from [circomlib](https://github.com/iden3/circomlib). We also use [`poseidon.circom`](https://github.com/iden3/circomlib/blob/master/circuits/poseidon.circom) (also found in circomlib) to verify our secret and nullifier are a leaf on our merkle tree.

This circuit will take 5 input signals, and no output signals.

```
  signal input root;
  signal private input key;
  signal private input secret;
  signal private input nullifier;
  signal private input siblings[nLevels];
```

`root` is the current root of the merkle tree. This is our only public signal in this circuit and will be enforced with our smart contract.

`key` is the index at which we will prove our secret resides.

`secret` is our secret number that we do not want to reveal.

`nullifier` is another secret number we use to hash our secret against. We include this signal to make this circuit more extensible if we decide to modify it in the future.

`siblings` is an array of the intermediate hashes up to the root of the merkle tree. This input is private as we do not want to reveal the path to our secret, that would give away our identity.

# Smart Contract

### Verifier

[`hardhat-circom`](https://github.com/projectsophon/hardhat-circom) has generated us a library with verification functions for our circuits above.

# 💌 P.S.

🌍 You need an RPC key for production deployments/Apps, create an [Alchemy](https://www.alchemy.com/) account and replace the value of `ALCHEMY_KEY = xxx` in `packages/react-app/src/constants.js`

### Automated with Gitpod

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#github.com/scaffold-eth/scaffold-eth)****

# 💬 Support Chat

Join the telegram [support chat 💬](https://t.me/joinchat/KByvmRe5wkR-8F_zz6AjpA) to ask questions and find others building with 🏗 scaffold-eth!

---

🙏 Please check out our [Gitcoin grant](https://gitcoin.co/grants/2851/scaffold-eth) too!
